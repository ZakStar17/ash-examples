#version 460
layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

struct Projectile {
  vec2 pos;
  vec2 vel;
};

layout(push_constant) uniform PushConstantData {
  vec2 player_pos;
  float delta_time;  // time since last shader run in seconds

  uint target_projectile_count;
  uint cur_projectile_count;

  // contains position and velocity of the next projectiles
  Projectile next_projectiles[4];
} pc;

// data that will be read by the cpu in the next frame after the shader has run
layout(set = 0, binding = 0) restrict buffer CPUStorage {
  uint colliding;

  // index of the next projectile in pc.next_projectiles
  // can be negative after the atomic operation
  int pc_next_projectile_i;
  int new_projectile_count;
}
cpu_storage;

layout(set = 0, binding = 1) restrict readonly buffer ProjectileIn {
  Projectile projectiles[];
}
in_data;

layout(set = 0, binding = 2) restrict writeonly buffer ProjectileOut {
  Projectile projectiles[];
}
out_data;


bool out_of_bounds(Projectile p) {
  // no out of bounds for top of screen
  return p.pos[0] < -1.1 || p.pos[0] > 1.1 || p.pos[1] > 1.1;
}

void main() {
  uint i = gl_GlobalInvocationID.x;
  if (i >= pc.target_projectile_count) {
    return;
  }

  if (i > pc.cur_projectile_count) {
    return;
  }
  if (i == pc.cur_projectile_count) {
    // define only one invocation to add new projectiles 
    // this is in order for no holes to exist where projectiles are undefined 
    // (as pc.next_projectiles has finite length)

    int wanted_new = int(pc.target_projectile_count - pc.cur_projectile_count);
    int max_next_projectile_i = atomicAdd(cpu_storage.pc_next_projectile_i, 0 - wanted_new);
    for (int new_i = 0; new_i <= max_next_projectile_i; new_i++) {
      out_data.projectiles[i + new_i] = pc.next_projectiles[new_i];
    }

    // doesn't need to be atomic as this is the only invocation writing it
    cpu_storage.new_projectile_count = max_next_projectile_i - 1;

    return;
  }

  Projectile p_in = in_data.projectiles[i];

  Projectile p_out;
  p_out.vel = p_in.vel + (p_in.vel * 0.1 * pc.delta_time);
  p_out.pos += p_in.vel * pc.delta_time;

  if (out_of_bounds(p_out)) {
    // Replace projectile with new one (in this case it is more like teleporting it to a new place)
    // This can fail if there are no new projectiles in push constant data,
    // but it is fine in this case as the projectile will be out of screen
    int next_i = atomicAdd(cpu_storage.pc_next_projectile_i, -1);
    if (next_i >= 0) {
      p_out = pc.next_projectiles[next_i];
    }
  } else {
    // collision test
    if (distance(p_out.pos, pc.player_pos) < 0.05) {
      atomicCompSwap(cpu_storage.colliding, 0, 1);
    }
  }

  out_data.projectiles[i] = p_out;
}
