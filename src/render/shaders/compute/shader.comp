#version 460
layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

const uint MAX_RANDOM_VALUES = 16384;

struct Bullet {
  vec2 pos;
  vec2 vel;
};

layout(push_constant) uniform PushConstantData {
  vec2 player_pos;
  float delta_time;  // time since last shader run in seconds

  uint bullet_count;
} pc;

layout(set = 0, binding = 0) restrict uniform Random {
  float values[MAX_RANDOM_VALUES];
} 
random;

// data that will be read by the cpu in the next frame after the shader has run
layout(set = 0, binding = 1) restrict buffer CPUOut {
  uint colliding;

  // current index of Random
  uint random_uniform_index;
}
cpu_out;

layout(set = 0, binding = 2) restrict readonly buffer DataIn {
  Bullet bullets[];
}
data_in;

layout(set = 0, binding = 3) restrict writeonly buffer DataOut {
  Bullet bullets[];
}
data_out;

bool out_of_bounds(Bullet p) {
  return p.pos[1] > 1.1;
}

Bullet new_bullet() {
  uint next_i = atomicAdd(cpu_out.random_uniform_index, 2);
  float random1 = random.values[next_i-1];
  float random2 = random.values[next_i-2];

  Bullet b = Bullet(
    vec2((random1 - 0.5) * 2.2, -1.2),
    vec2(0.0, 0.1 + (random2 / 2.0))
  );
  return b;
}

void main() {
  uint i = gl_GlobalInvocationID.x;
  if (i >= pc.bullet_count) {
    return;
  }

  Bullet p_in = data_in.bullets[i];

  Bullet p_out;
  p_out.vel = p_in.vel + (p_in.vel * 0.1 * pc.delta_time);
  p_out.pos = p_in.pos + (p_in.vel * pc.delta_time);

  if (out_of_bounds(p_out)) {
    p_out = new_bullet();
  } else {
    // collision test
    if (distance(p_out.pos, pc.player_pos) < 0.05) {
      atomicCompSwap(cpu_out.colliding, 0, 1);
    }
  }

  data_out.bullets[i] = p_out;
}
