#version 460
layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

const int BULLET_REPLACEMENTS_COUNT = 4;

struct Projectile {
  vec2 pos;
  vec2 vel;
};

layout(push_constant) uniform PushConstantData {
  vec2 player_pos;
  float delta_time;  // time since last shader run in seconds

  uint projectile_count;

  // next projectiles to be added in order to reach target_count
  // or replace the ones that are out of bounds
  Projectile bullet_replacements[BULLET_REPLACEMENTS_COUNT];
} pc;

// data that will be read by the cpu in the next frame after the shader has run
layout(set = 0, binding = 0) restrict buffer CPUOut {
  uint colliding;
  uint pc_projectile_replacements_i;
}
cpu_out;

layout(set = 1, binding = 0) restrict readonly buffer DataIn {
  Projectile projectiles[];
}
data_in;

layout(set = 1, binding = 1) restrict writeonly buffer DataOut {
  Projectile projectiles[];
}
data_out;

bool out_of_bounds(Projectile p) {
  return p.pos[1] > 1.1;
}

Projectile invalid_projectile() {
  float positive_inf = uintBitsToFloat(0x7F800000);

  Projectile p;
  p.pos = vec2(positive_inf, positive_inf);
  return p;
}

void main() {
  uint i = gl_GlobalInvocationID.x;
  if (i >= pc.projectile_count) {
    return;
  }

  Projectile p_in = data_in.projectiles[i];

  Projectile p_out;
  p_out.vel = p_in.vel + (p_in.vel * 0.1 * pc.delta_time);
  p_out.pos = p_in.pos + (p_in.vel * pc.delta_time);

  if (out_of_bounds(p_out)) {
    // Replace projectile with new one (in this case it is more like teleporting it to a new place)
    uint next_i = atomicAdd(cpu_out.pc_projectile_replacements_i, 1);
    if (next_i < BULLET_REPLACEMENTS_COUNT) {
      p_out = pc.bullet_replacements[next_i];
    } else {
      p_out = invalid_projectile();
    }
  } else {
    // collision test
    if (distance(p_out.pos, pc.player_pos) < 0.05) {
      atomicCompSwap(cpu_out.colliding, 0, 1);
    }
  }

  data_out.projectiles[i] = p_out;
}
