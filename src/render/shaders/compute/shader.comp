#version 460
layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

const int PC_NEXT_PROJECTILES_SIZE = 4;

struct Projectile {
  vec2 pos;
  vec2 vel;
};

layout(push_constant) uniform PushConstantData {
  vec2 player_pos;
  float delta_time;  // time since last shader run in seconds

  uint target_projectile_count;
  uint cur_projectile_count;

  // next projectiles to be added in order to reach target_count
  // or replace the ones that are out of bounds
  Projectile next_projectiles[PC_NEXT_PROJECTILES_SIZE];
} pc;

// data that will be read by the cpu in the next frame after the shader has run
layout(set = 0, binding = 0) restrict buffer CPUOut {
  uint colliding;
  uint pc_next_projectiles_i; // current pc.next_projectiles index for all invocations
  uint new_projectile_count;
}
cpu_out;

layout(set = 0, binding = 1) restrict readonly buffer DataIn {
  Projectile projectiles[];
}
data_in;

layout(set = 0, binding = 2) restrict writeonly buffer DataOut {
  Projectile projectiles[];
}
data_out;

Projectile invalid_projectile() {
  float positive_inf = uintBitsToFloat(0x7F800000);

  Projectile p;
  p.pos = vec2(positive_inf, positive_inf);
  return p;
}

bool out_of_bounds(Projectile p) {
  // no out of bounds for top of screen
  return p.pos[0] < -1.1 || p.pos[0] > 1.1 || p.pos[1] > 1.1;
}

void main() {
  uint i = gl_GlobalInvocationID.x;
  if (i >= pc.target_projectile_count) {
    return;
  }

  if (i > pc.cur_projectile_count) {
    return;
  }
  if (i == pc.cur_projectile_count) {
    // define only one invocation to add new projectiles 
    // this is in order for no holes to exist where projectiles are undefined 
    // (as pc.next_projectiles has finite length)

    uint wanted_new = pc.target_projectile_count - pc.cur_projectile_count;
    // consume remaining next projectiles
    uint next_i = atomicAdd(cpu_out.pc_next_projectiles_i, wanted_new);
    if (next_i < PC_NEXT_PROJECTILES_SIZE) {
      uint j = 0;
      for (; j < wanted_new; j++) {
        if (next_i < PC_NEXT_PROJECTILES_SIZE) {
          data_out.projectiles[i + j] = pc.next_projectiles[next_i];
          next_i += 1;
        } else {
          data_out.projectiles[i + j] = invalid_projectile();
        }
      }

      // doesn't need to be atomic as this is the only invocation writing it
      cpu_out.new_projectile_count = j;
    }

    return;
  }

  Projectile p_in = data_in.projectiles[i];

  Projectile p_out;
  p_out.vel = p_in.vel + (p_in.vel * 0.1 * pc.delta_time);
  p_out.pos += p_in.vel * pc.delta_time;

  if (out_of_bounds(p_out)) {
    // Replace projectile with new one (in this case it is more like teleporting it to a new place)
    uint next_i = atomicAdd(cpu_out.pc_next_projectiles_i, 1);
    if (next_i < PC_NEXT_PROJECTILES_SIZE) {
      p_out = pc.next_projectiles[next_i];
    } else {
      p_out = invalid_projectile();
    }
  } else {
    // collision test
    if (distance(p_out.pos, pc.player_pos) < 0.05) {
      atomicCompSwap(cpu_out.colliding, 0, 1);
    }
  }

  data_out.projectiles[i] = p_out;
}
